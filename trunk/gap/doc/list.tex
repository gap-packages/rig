\Chapter{List of functions}

The following is a list of the functions available in the {\RiG} package. 

\>AbelianRack( <n> );
\>TrivialRack( <n> );

creates an abelian rack of size <n>. For example:

\beginexample
gap> AbelianRack(3);
[ [  1,  2,  3 ],
  [  1,  2,  3 ],
  [  1,  2,  3 ] ]
\endexample

\>AffineCyclicRack( <n>, <x> )

creates an affine rack associated to the cyclic group of order <n> and
the multiplication by <x>. For example, the dihedral rack of size 3
can be obtained as:

\beginexample
gap> AffineCyclicRack(3,2);
[ [  1,  3,  2 ],
  [  3,  2,  1 ],
  [  2,  1,  3 ] ]
\endexample

\>AffineRack( <field>, <field_element> )

creates an affine rack associated to <field> and the multiplication
by the <field_element>. For example:

\beginexample
gap> AffineRack(GF(3), Z(3));
[ [  1,  3,  2 ],
  [  3,  2,  1 ],
  [  2,  1,  3 ] ]
\endexample

\>AlexanderRack( <n>, <s>, <t> )

returns the Alexander rack of size <n> associated to <s> and <t>.
%The rack
%structure $i\triangleright j=si+tj$, $i,j\in\{1,...,n\}$.  
%if $<s>(<t>+<s>-1)=0$.
If $s=1-t$ then the result is the Alexander quandle.

\>CyclicRack( <n> )

returns the cyclic rack of order <n>. For example:

\beginexample
gap> CyclicRack(3);
[ [ 2,  3,  1 ],
  [ 2,  3,  1 ],
  [ 2,  3,  1 ] ]
\endexample

\>CoreRack( <group> )

returns the core rack of the group <group>. For example:

\beginexample
gap> CoreRack(CyclicGroup(3));
[ [  1,  3,  2 ],
  [  3,  2,  1 ],
  [  2,  1,  3 ] ]
\endexample

\>DihedralRack( <n> ) 

creates a dihedral rack of size <n>. For example:

\beginexample
gap> DihedralRack(5);
[ [  1,  5,  4,  3,  2 ],
  [  3,  2,  1,  5,  4 ],
  [  5,  4,  3,  2,  1 ],
  [  2,  1,  5,  4,  3 ],
  [  4,  3,  2,  1,  5 ] ]
\endexample

\>DirectProductOfRack( <rack1>, <rack2> )

returns the direct product of <rack1> and <rack2>.
For example:

\beginexample
gap> DirectProductOfRacks(DihedralRack(3), TrivialRack(2));
[ [  1,  2,  5,  6,  3,  4 ],
  [  1,  2,  5,  6,  3,  4 ],
  [  5,  6,  3,  4,  1,  2 ],
  [  5,  6,  3,  4,  1,  2 ],
  [  3,  4,  1,  2,  5,  6 ],
  [  3,  4,  1,  2,  5,  6 ] ]
\endexample

\>HomogeneousRack( <group>, <automorphism> )
\>TwistedHomogeneousRack( <group>, <automorphism> )

creates a (twisted)homogeneous rack associated to the <automorphism> 
of the <group> given. For example:

\beginexample
gap> f := ConjugatorAutomorphism(SymmetricGroup(3), (1,2)));;
gap> HomogeneousRack(SymmetricGroup(3), f);
[ [  1,  6,  3,  5,  4,  2 ],
  [  4,  2,  6,  1,  5,  3 ],
  [  1,  6,  3,  5,  4,  2 ],
  [  5,  3,  2,  4,  1,  6 ],
  [  4,  2,  6,  1,  5,  3 ],
  [  5,  3,  2,  4,  1,  6 ] ]
\endexample

\>RackByListOfPermutations( <list> )

returns the rack given by the list of permutations given in <list>. For example:

\beginexample
gap> RackFromListOfPermutations([(2,3),(1,3),(1,2)]);                                         
[ [  1,  3,  2 ],
  [  3,  2,  1 ],
  [  2,  1,  3 ] ]
\endexample

\>Rank(<rack>)

return the rank of <rack>. If <rack> is a quandle, the result is 1.

\>AutomorphismGroup( <rack> )

returns the group of automorphism of <rack>. For example:

\beginexample
gap> AutomorphismGroup(TrivialRack(3));                  
Group([ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ])
\endexample

\>InnerGroup( <rack> )

returns the inner group of the rack. For example

\beginexample
gap> InnerGroup(DihedralRack(3));
Group([ (2,3), (1,3), (1,2) ])
gap> InnerGroup(TrivialRack(5)); 
Group(())
\endexample

\>IsomorphismRack( <r>, <s> )

computes  an  isomorphism  between  the  racks  <r>  and  <s> if they are
isomorphic and returns `fail' otherwise.

\beginexample
gap> a := Rack(AlternatingGroup(4), (1,2,3));;
gap> b := Rack(AlternatingGroup(4), (1,3,2));;
gap> c := AbelianRack(4);
gap> IsomorphismRacks(a,b);
(3,4)
gap> IsomosphismRacks(a,c);
fail
\endexample

\>Rack( <matrix> ) F

creates a rack structure over the set $X=\{1,...,n\}$ with the structure 
given by <matrix>. For example, to get the abelian rack of two elements:

\beginexample
gap> a := AbelianRack(2);;
gap> b := Rack([[1,2],[1,2]]); 
[ [  1,  2 ],
  [  1,  2 ] ]
gap> a=b;
true
\endexample

\>Rack( <group>, <group_element> ) F

creates a rack structure from the conjugacy class in <group> of 
<group_element>. For example, the rack associated to the 
vertices of the tetrahedron is the rack of the conjugacy class
of (1,2,3) in the alternating group in four letters:

\beginexample
gap> Rack(AlternatingGroup(4), (1,2,3));
[ [  1,  3,  4,  2 ],
  [  4,  2,  1,  3 ],
  [  2,  4,  3,  1 ],
  [  3,  1,  2,  4 ] ]
\endexample

\>Rack( <set> )

creates a rack structure from the elements of the <set>. For example:

\beginexample
gap> set := Set([(1,2),(2,3),(1,3)]);;
gap> Rack(set) = Rack(SymmetricGroup(3), (1,2));
true
\endexample


\>BoundaryMap( <rack>, <n> ) 

computed the boundary map...

\>RackCohomology ( <rack>, <order> ) F

computes the abelian rack cohomology. 

\beginexample
gap> RackCohomology(DihedralRack(5),3);
????
gap> RackCohomology(AffineCyclicRack(10,3),2);
????
\endexample

\>RackHomology ( <rack>, <order> ) F

computes the abelian rack homology. 

\beginexample
gap> RackHomology(DihedralRack(3),4);
????
gap> RackHomology(AffineCyclicRack(10,3),2);
????
\endexample

\> QuantumSymmetrizer( <rack>, <q>, <n> )

computes the quantum symmetrizer of degree <n>.

\> Dimension( <rack>, <q>, <n> )

computes the dimension in degree <n> of the Nichols algebra generated 
by the <rack> and the 2-cocycle <q>. In the following example we 
compute all dimensions of a known 12-dimensional Nichols algebra.

\beginexample
gap> r := DihedralRack(3);;
gap> q := [ [ -1, -1, -1 ], [ -1, -1, -1 ], [ -1, -1, -1 ] ];;
gap> for i in [0..5] do
Print("Degree ", i, ", dimension=", Dimension(r,q,i), "\n");
od;
Degree 0, dimension=1
Degree 1, dimension=3
Degree 2, dimension=4
Degree 3, dimension=3
Degree 4, dimension=1
Degree 5, dimension=0
\endexample
% now is <data>
\> Relations4GAP( <rack>, <q>, <n> )

returns the relation in degree <n> of the Nichols algebra generated by
<rack> and the 2-cocycle <q>. The relations are returned in gbnp format. 
In the following example we calculate all relations in degree two of a 
12-dimensional Nichols algebra.

\beginexample
gap> r := DihedralRack(3);;
gap> q := [ [ -1, -1, -1 ], [ -1, -1, -1 ], [ -1, -1, -1 ] ];;
gap> rels := Relations4GAP(r, q, 2);;
gap> PrintNPList(rels);
 a^2 
 b^2 
 ab + bc + ca 
 ac + ba + cb 
 c^2 
\endexample

\> RackOrbit( <rack>, <i> )

returns the orbit of the element <i>, given by the action of 
the inner group.

\beginexample
gap> r := DihedralRack(4);;
gap> RackOrbit(r, 1);
[1, 3]
\endexample

\>Nr_k ( <rack>, <n> )

returns the number of $j$ such that the braided orbit of $(1,j)$ 
has <n> elements.

\beginexample
gap> Check := function(rack)
> local n,s,d;
> d := Size(rack);
> s := 0;
> for n in [3..d^2] do
>   s := s+(n-2)*Nr_k(rack,n)/(2*n);
> od;
> if s <= 1 then
>   return s;
> else
>   return fail;
> fi;
> end;
gap> a4 := AlternatingGroup(4);;
gap> s4 := SymmetricGroup(4);;
gap> s5 := SymmetricGroup(5);;
gap> Check(RackFromAConjugacyClass(a4, (1,2,3)));
1/2
gap> Check(RackFromAConjugacyClass(s4, (1,2)));    
2/3
gap> Check(RackFromAConjugacyClass(s4, (1,2,3,4));
2/3
gap> Check(RackFromAConjugacyClass(s5, (1,2)));    
1
gap> Check(AffineCyclicRack(5,2));                            
1
gap> Check(AffineCyclicRack(5,3));
1
gap> Check(AffineCyclicRack(7,5));  
1
gap> Check(AffineCyclicRack(7,3));
1
gap> Check(DihedralRack(3));      
1/3
\endexample

\>Nr_l ( <rack>, <n> )

%returns the number $Size(<rack>)*Nr_k(<rack>,<n>)/n$.  
returns the number of braided orbits with <n> elements, when
<rack> is of group-type.

\>Braiding ( <rack> )

returns the braiding given by <rack>.

\beginexample
gap> Display(Braiding(TrivialRack(2)));  
[ [  1,  0,  0,  0 ],
  [  0,  0,  1,  0 ],
  [  0,  1,  0,  0 ],
  [  0,  0,  0,  1 ] ]
\endexample

\>SubracksUpToIso ( <rack>, <subr>, <n> )

returns all the subracks of <rack> containing <subr> of 
size less or equal than <n> (up to rack isomorphism).

\beginexample
gap> r := DihedralRack(8);;
gap> subracks := SubracksUpToIso(r,[1],8);;
gap> for s in subracks do
> Print(Size(s),"\n");
> od;
1
8
4
2
\endexample

\>IsConnected ( <rack> )
\>IsIndecomposable ( <rack> )

returns true if the rack is indecomposable (i.e. connected).

\beginexample
gap> r := DihedralRack(3);;
gap> IsIndecomposable(r);
true
gap> s := DihedralRack(4);;
gap> IsIndecomposable(s);
false
\endexample

\>IsHomogeneous ( <rack> )

returns true is the automorphism group of the rack acts
transitively on <rack>.

\>AreHomologous( <rack>, <q1>, <q2> )
\>TorsionGenerators( <rack>, <n> )
\>SecondRackCohomologyTorsionGenerators( <rack> )
\>LocalExponent
\>LocalExponents
\>Degree
\>RackAction
\>InverseRackAction
\>Hom


