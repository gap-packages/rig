\Chapter{List of functions}

The following is a list of the functions available in the {\RiG} package. 

\>IsAffineIndecomposableQuandle( <quandle> );

checks if the <quandle> is an affine quandle. This function only works 
with indecomposable quandles. For example:

\beginexample
gap> r := SmallQuandle(5,1);;
gap> IsAffineIndecomposableQuandle(r);
true
gap> s := SmallQuandle(6,1);;
gap> IsAffineIndecomposableQuandle(s);
# It contains commuting elements
false
\endexample

\>AbelianRack( <n> );
\>TrivialRack( <n> );

creates an abelian rack of size <n>. For example:

\beginexample
gap> r := TrivialRack(3);;
gap> Display(r);
rec(
  aut := "",
  basis := "",
  comments := "",
  env := "",
  inn := "",
  isRack := true,
  labels := [ 1 .. 3 ],
  matrix := [ [ 1, 2, 3 ], [ 1, 2, 3 ], [ 1, 2, 3 ] ],
  size := 3 )
\endexample

\>AffineCyclicRack( <n>, <x> )

creates an affine rack associated to the cyclic group of order <n> and
the multiplication by <x>. For example, the dihedral rack of size 3
can be obtained as:

\beginexample
gap> r := AffineCyclicRack(3,2);;
gap> Display(r);
rec(
  aut := "",
  basis := "",
  comments := "",
  env := "",
  inn := "",
  isRack := true,
  labels := [ 1 .. 3 ],
  matrix := [ [ 1, 3, 2 ], [ 3, 2, 1 ], [ 2, 1, 3 ] ],
  size := 3 )
\endexample

\>AffineRack( <field>, <field_element> )

creates an affine rack associated to <field> and the multiplication
by the <field_element>. For example:

\beginexample
gap> r := AffineRack(GF(3), Z(3));;
gap> Display(r);
rec(
  aut := "",
  basis := "",
  comments := "",
  env := "",
  inn := "",
  isRack := true,
  labels := [ 1 .. 3 ],
  matrix := [ [ 1, 3, 2 ], [ 3, 2, 1 ], [ 2, 1, 3 ] ],
  size := 3 )
\endexample

\>AlexanderRack( <n>, <s>, <t> )

returns the Alexander rack of size <n> associated to <s> and <t>.
%The rack
%structure $i\triangleright j=si+tj$, $i,j\in\{1,...,n\}$.  
%if $<s>(<t>+<s>-1)=0$.
If $s=1-t$ then the result is the Alexander quandle.

\>CyclicRack( <n> )

returns the cyclic rack of order <n>. For example:

\beginexample
gap> r := CyclicRack(3);;
gap> Display(r);
rec(
  aut := "",
  basis := "",
  comments := "",
  env := "",
  inn := "",
  isRack := true,
  labels := [ 1 .. 3 ],
  matrix := [ [ 2, 3, 1 ], [ 2, 3, 1 ], [ 2, 3, 1 ] ],
  size := 3 )
\endexample

\>CoreRack( <group> )

returns the core rack of the group <group>. For example:

\beginexample
gap> r := CoreRack(CyclicGroup(3));;
gap> Display(r);
rec(
  aut := "",
  basis := "",
  comments := "",
  env := "",
  inn := "",
  isRack := true,
  labels := [ 1 .. 3 ],
  matrix := [ [ 1, 3, 2 ], [ 3, 2, 1 ], [ 2, 1, 3 ] ],
  size := 3 )
\endexample

\>DihedralRack( <n> ) 

creates a dihedral rack of size <n>. For example:

\beginexample
gap> r := DihedralRack(5);;
gap> Display(r.matrix);
[ [  1,  5,  4,  3,  2 ],
  [  3,  2,  1,  5,  4 ],
  [  5,  4,  3,  2,  1 ],
  [  2,  1,  5,  4,  3 ],
  [  4,  3,  2,  1,  5 ] ]
\endexample

\>DirectProductOfRack( <rack1>, <rack2> )

returns the direct product of <rack1> and <rack2>.
For example:

\beginexample
gap> r := DirectProductOfRacks(DihedralRack(3), TrivialRack(2));;
gap> Display(r.matrix);
[ [  1,  2,  5,  6,  3,  4 ],
  [  1,  2,  5,  6,  3,  4 ],
  [  5,  6,  3,  4,  1,  2 ],
  [  5,  6,  3,  4,  1,  2 ],
  [  3,  4,  1,  2,  5,  6 ],
  [  3,  4,  1,  2,  5,  6 ] ]
\endexample

\>HomogeneousRack( <group>, <automorphism> )
\>TwistedHomogeneousRack( <group>, <automorphism> )

creates a (twisted)homogeneous rack associated to the <automorphism> 
of the <group> given. For example:

\beginexample
gap> f := ConjugatorAutomorphism(SymmetricGroup(3), (1,2));;
gap> r := HomogeneousRack(SymmetricGroup(3), f);;
gap> Display(r.matrix);
[ [  1,  6,  3,  5,  4,  2 ],
  [  4,  2,  6,  1,  5,  3 ],
  [  1,  6,  3,  5,  4,  2 ],
  [  5,  3,  2,  4,  1,  6 ],
  [  4,  2,  6,  1,  5,  3 ],
  [  5,  3,  2,  4,  1,  6 ] ]
\endexample

\>RackFromPermutations( <list> )

returns the rack given by the list of permutations given in <list>. For example:

\beginexample
gap> r := RackFromPermutations([(2,3),(1,3),(1,2)]);;
gap> Display(r.matrix);
[ [  1,  3,  2 ],
  [  3,  2,  1 ],
  [  2,  1,  3 ] ]
\endexample

\>Rank(<rack>)

return the rank of <rack>. If <rack> is a quandle, the result is 1.

\>AutomorphismGroup( <rack> )

returns the group of automorphism of <rack>. For example:

\beginexample
gap> AutomorphismGroup(TrivialRack(3));
Group([ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ])
\endexample

\>InnerGroup( <rack> )

returns the inner group of the rack. For example

\beginexample
gap> InnerGroup(DihedralRack(3));
Group([ (2,3), (1,3), (1,2) ])
gap> InnerGroup(TrivialRack(5));
Group(())
\endexample

\>IsomorphismRack( <r>, <s> )

computes  an  isomorphism  between  the  racks  <r>  and  <s> if they are
isomorphic and returns `fail' otherwise.

\beginexample
gap> a := Rack(AlternatingGroup(4), (1,2,3));;
gap> b := Rack(AlternatingGroup(4), (1,3,2));;
gap> c := AbelianRack(4);;
gap> IsomorphismRacks(a,b);
(3,4)
gap> IsomorphismRacks(a,c);
fail
\endexample

\>IsMorphism ( <f>, <r>, <s> )

Checks if <f> is a rack morphism from <r> to <s>

\beginexample
gap> r := SmallQuandle(6,1);;
gap> s := DihedralRack(3);;
gap> for f in Hom(r,s) do Print("Is f=", f, ", a rack morphism? ", IsMorphism(f, r, s), "\n"); od;
Is f=[ 1, 1, 1, 1, 1, 1 ], a rack morphism? true
Is f=[ 1, 1, 2, 2, 3, 3 ], a rack morphism? true
Is f=[ 1, 1, 3, 3, 2, 2 ], a rack morphism? true
Is f=[ 2, 2, 1, 1, 3, 3 ], a rack morphism? true
Is f=[ 2, 2, 2, 2, 2, 2 ], a rack morphism? true
Is f=[ 2, 2, 3, 3, 1, 1 ], a rack morphism? true
Is f=[ 3, 3, 1, 1, 2, 2 ], a rack morphism? true
Is f=[ 3, 3, 2, 2, 1, 1 ], a rack morphism? true
Is f=[ 3, 3, 3, 3, 3, 3 ], a rack morphism? true
\endexample

\>IsQuotient ( <r>, <s> )

checks if there exists an epimorphism of racks from <r> to <s> The following
example shows that the two indecomposable quandles of size 6 are not simple.

\beginexample
gap> IsQuotient(SmallQuandle(6,1), DihedralRack(3));
[ 1, 1, 2, 2, 3, 3 ]
gap> IsQuotient(SmallQuandle(6,2), DihedralRack(3));
[ 1, 1, 2, 2, 3, 3 ]
\endexample

\beginexample
gap> IsQuotient(DihedralRack(4), TrivialRack(2));
[ 1, 2, 1, 2 ]
\endexample

\>Rack( <matrix> ) F

creates a rack structure over the set $X=\{1,...,n\}$ with the structure 
given by <matrix>. For example, to get the abelian rack of two elements:

\beginexample
gap> a := AbelianRack(2);;
gap> b := Rack([[1,2],[1,2]]);;
gap> Display(b.matrix);
[ [  1,  2 ],
  [  1,  2 ] ]
gap> a=b;
true
\endexample

\>Rack( <group>, <group_element> ) F

creates a rack structure from the conjugacy class in <group> of 
<group_element>. For example, the rack associated to the 
vertices of the tetrahedron is the rack of the conjugacy class
of (1,2,3) in the alternating group in four letters:

\beginexample
gap> r := Rack(AlternatingGroup(4), (1,2,3));;
gap> Display(r.matrix);
[ [  1,  3,  4,  2 ],
  [  4,  2,  1,  3 ],
  [  2,  4,  3,  1 ],
  [  3,  1,  2,  4 ] ]
\endexample

\>Rack( <set> )

creates a rack structure from the elements of the <set>. For example:

\beginexample
gap> set := Set([(1,2),(2,3),(1,3)]);;
gap> Rack(set) = Rack(SymmetricGroup(3), (1,2));
true
\endexample

\>BoundaryMap( <rack>, <n> ) F 

computes the rack boundary map.

\>RackHomology ( <rack>, <order> ) F
\>RackCohomology ( <rack>, <order> ) F

computes the abelian rack (co)homology. 

\beginexample
gap> RackCohomology(DihedralRack(3),2);
[ 1, [  ] ]
gap> RackCohomology(TrivialRack(3),2);
[ 9, [  ] ]
gap> RackHomology(TrivialRack(2),2);
[ 4, [  ] ]
gap> RackHomology(DihedralRack(4),2);
[ 4, [ 2, 2 ] ]
\endexample

\> QuantumSymmetrizer( <rack>, <q>, <n> )

computes the quantum symmetrizer of degree <n>.

\> Dimension( <nichols_datum>, <n> )

computes the dimension in degree <n> of the Nichols algebra <nichols_datum>.
In the following example we compute all dimensions of a known 12-dimensional
Nichols algebra.

\beginexample
gap> r := DihedralRack(3);;
gap> q := [ [ -1, -1, -1 ], [ -1, -1, -1 ], [ -1, -1, -1 ] ];;
gap> n := NicholsDatum(r, q, Rationals);;
gap> for i in [0..5] do
>   Print("Degree ", i, ", dimension=", Dimension(n,i), "\n");
> od;
Degree 0, dimension=1
Degree 1, dimension=3
Degree 2, dimension=4
Degree 3, dimension=3
Degree 4, dimension=1
Degree 5, dimension=0
\endexample

\> Relations4GAP( <nichols_datum>, <n> )

returns the relation in degree <n> of the Nichols algebra <nichols_datum>. The
relations are returned in gbnp format.  In the following example we calculate
all relations in degree two of a 12-dimensional Nichols algebra.

\beginexample
gap> r := DihedralRack(3);;
gap> q := [ [ -1, -1, -1 ], [ -1, -1, -1 ], [ -1, -1, -1 ] ];;
gap> rels := Relations4GAP(r, q, 2);;
gap> PrintNPList(rels);
 a^2 
 b^2 
 ab + bc + ca 
 ac + ba + cb 
 c^2 
\endexample

\> RackOrbit( <rack>, <i> )

returns the orbit of the element <i>, given by the action of the inner group.

\beginexample
gap> r := DihedralRack(4);;
gap> RackOrbit(r, 1);
[ 1, 3 ]
\endexample

\>Nr_k ( <rack>, <n> )

returns the number of $j$ such that the braided orbit of $(1,j)$ 
has <n> elements.

\beginexample
gap> Check := function(rack)
> local n,s,d;
> d := Size(rack);
> s := 0;
> for n in [3..d^2] do
>   s := s+(n-2)*Nr_k(rack,n)/(2*n);
> od;
> if s <= 1 then
>   return s;
> else
>   return fail;
> fi;
> end;;
gap> a4 := AlternatingGroup(4);;
gap> s4 := SymmetricGroup(4);;
gap> s5 := SymmetricGroup(5);;
gap> Check(RackFromAConjugacyClass(a4, (1,2,3)));
1/2
gap> Check(RackFromAConjugacyClass(s4, (1,2)));
2/3
gap> Check(RackFromAConjugacyClass(s4, (1,2,3,4)));
2/3
gap> Check(RackFromAConjugacyClass(s5, (1,2)));
1
gap> Check(AffineCyclicRack(5,2));
1
gap> Check(AffineCyclicRack(5,3));
1
gap> Check(AffineCyclicRack(7,5));
1
gap> Check(AffineCyclicRack(7,3));
1
gap> Check(DihedralRack(3));
1/3
\endexample

\>Nr_l ( <rack>, <n> )

returns the number of braided orbits with <n> elements, when <rack> is of
group-type.

\>Braiding ( <rack> )

returns the braiding given by <rack>.

\beginexample
gap> Display(Braiding(TrivialRack(2)));
[ [  1,  0,  0,  0 ],
  [  0,  0,  1,  0 ],
  [  0,  1,  0,  0 ],
  [  0,  0,  0,  1 ] ]
\endexample

\>SubracksUpToIso ( <rack>, <subr>, <n> )

returns all the subracks of <rack> containing <subr> of size less or equal than
<n> (up to rack isomorphism).

\beginexample
gap> r := DihedralRack(8);;
gap> subracks := SubracksUpToIso(r,[1],8);;
gap> for s in subracks do
> Print(Size(s),"\n");
> od;
1
8
4
2
\endexample

\>IsConnected ( <rack> )
\>IsIndecomposable ( <rack> )

returns true if the rack is indecomposable (i.e. connected).

\beginexample
gap> r := DihedralRack(3);;
gap> IsIndecomposable(r);
true
gap> s := DihedralRack(4);;
gap> IsIndecomposable(s);
false
\endexample

\>IsHomogeneous ( <rack> )

returns true is the automorphism group of the rack acts transitively on <rack>.

\>IsHomologous( <rack>, <q1>, <q2> )
\>TorsionGenerators( <rack>, <n> )
\>SecondCohomologyTorsionGenerators( <rack> )
\>LocalExponent( <rack>, <i>, <j> )
\>LocalExponents( <rack> )
\>Degree( <rack> )
\>RackAction( <rack>, <i>, <j> )
\>InverseRackAction( <rack>, <i>, <j> )
\>Hom( <rack1>, <rack2> )

\>Permutations( <rack> )

returns the list of permutations generating the <rack>.

\beginexample
gap> r := TetrahedronRack();;
gap> Permutations(r);
[ (2,3,4), (1,4,3), (1,2,4), (1,3,2) ]
\endexample

\>HurwitzOrbit( <rack>, <vector> )

computes the Hurwitz orbit of the <vector>

\beginexample
gap> r := DihedralRack(3);;
gap> HurwitzOrbit(r, [1,1,1]);
[ [ 1, 1, 1 ] ]
gap> HurwitzOrbit(r, [1,2,3]);
[ [ 1, 2, 3 ], [ 3, 1, 3 ], [ 1, 1, 2 ], [ 2, 3, 3 ], [ 3, 2, 1 ], 
  [ 1, 3, 1 ], [ 3, 3, 2 ], [ 2, 1, 1 ] ]
\endexample 

\>HurwitzOrbits( <rack>, <n> )

returns the list of all <n>-Hurwitz orbits associated to the rack <rack>.

\beginexample
gap> r := DihedralRack(3);;
gap> HurwitzOrbits(r, 3);
[ [ [ 1, 1, 1 ] ], 
  [ [ 1, 1, 2 ], [ 1, 3, 1 ], [ 2, 1, 1 ], [ 1, 2, 3 ], [ 3, 2, 1 ], 
      [ 3, 1, 3 ], [ 3, 3, 2 ], [ 2, 3, 3 ] ], 
  [ [ 1, 1, 3 ], [ 1, 2, 1 ], [ 3, 1, 1 ], [ 1, 3, 2 ], [ 2, 3, 1 ], 
      [ 2, 1, 2 ], [ 2, 2, 3 ], [ 3, 2, 2 ] ], 
  [ [ 1, 2, 2 ], [ 3, 1, 2 ], [ 2, 3, 2 ], [ 3, 3, 1 ], [ 2, 1, 3 ], 
      [ 3, 2, 3 ], [ 2, 2, 1 ], [ 1, 3, 3 ] ], [ [ 2, 2, 2 ] ], 
  [ [ 3, 3, 3 ] ] ]
\endexample

\>HurwitzOrbitsRepresentatives( <rack>, <n> )

returns the list of representatives of all <n>-Hurwitz orbits of the rack <rack>.

\beginexample
gap> r := DihedralRack(3);;
gap> HurwitzOrbitsRepresentatives(r, 3);
[ [ 1, 1, 1 ], [ 1, 1, 2 ], [ 1, 1, 3 ], [ 1, 2, 2 ], [ 2, 2, 2 ], 
  [ 3, 3, 3 ] ]
\endexample

\>HurwitzOrbitsRepresentativesWS( <rack>, <n> )

returns the list of representatives of all <n>-Hurwitz orbits of the rack
<rack>. The sizes of each orbit are included.

\beginexample
gap> r := DihedralRack(3);;
gap> SizesHurwitzOrbits(r, 3);
[ 1, 8 ]
gap> HurwitzOrbitsRepresentativesWS(r, 3);
[ [ [ 1, 1, 1 ], 1 ], [ [ 1, 1, 2 ], 8 ], [ [ 1, 1, 3 ], 8 ], 
  [ [ 1, 2, 2 ], 8 ], [ [ 2, 2, 2 ], 1 ], [ [ 3, 3, 3 ], 1 ] ]
\endexample

\>NrHurwitzOrbits( <rack>, <n>, <size> )

returns the number of <n>-Hurwitz orbits of a given <size>

\beginexample
gap> r := DihedralRack(3);;
gap> NrHurwitzOrbits(r, 3, 8);
3
\endexample

\>SizesHurwitzOrbits( <rack>, <n> )

returns the sizes all <n>-Hurwitz orbits of <rack>.

\beginexample
gap> r := TetrahedronRack();;
gap> SizesHurwitzOrbits(r, 3);
[ 1, 8, 12 ]
\endexample

\>SmallIndecomposableQuandle( <size>, <number> )

returns the indecomposable quandle.

\>TetrahedronRack()

returns the rack associated to the vertices of the tetrahedron.

\beginexample
gap> r := TetrahedronRack();;
gap> Display(r.matrix);
[ [  1,  3,  4,  2 ],
  [  4,  2,  1,  3 ],
  [  2,  4,  3,  1 ],
  [  3,  1,  2,  4 ] ]
\endexample


